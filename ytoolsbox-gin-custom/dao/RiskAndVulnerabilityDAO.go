package dao

import (
	"main/dto"
	"main/model"
	"main/utils"

	"gorm.io/gorm"
)

// 查询所有脆弱性和风险的条目
func SelectAllRiskAndVulnerabilityDAO(db *gorm.DB, obj dto.GetAllRiskAndVulnerabilityDTOReq) ([]map[string]interface{}, int) {
	RiskAndVulnerabilityItem := []model.RiskAndVulnerability{}
	query := obj.Query
	pagenum := obj.Pagenum
	pagesize := obj.Pagesize
	myType := obj.Type
	map_taskItemList := []map[string]interface{}{}

	// 不带Query，返回全部
	// 否则返回like搜索后的结果
	if query == "" {
		if myType == "" {
			// 按照时间升序
			db.Order("created_at desc").Model(&model.RiskAndVulnerability{}).Find(&RiskAndVulnerabilityItem)
		} else {
			// 需要关注Type
			db.Order("created_at desc").Model(&model.RiskAndVulnerability{}).Where("\"type\" = ?", myType).Find(&RiskAndVulnerabilityItem)
		}

	} else {
		if myType == "" {
			// 按照时间升序
			db.Debug().Order("created_at desc").Where("\"name\" LIKE ?", "%"+query+"%").Model(&model.RiskAndVulnerability{}).Find(&RiskAndVulnerabilityItem)
		} else {
			db.Debug().Order("created_at desc").Where("\"name\" LIKE ?", "%"+query+"%").Where("\"type\" = ?", myType).Model(&model.RiskAndVulnerability{}).Find(&RiskAndVulnerabilityItem)
		}

	}

	DefaultLength := len(RiskAndVulnerabilityItem)

	// 把一个自定义结构体的array 转换成map的array
	// 这里用了json的方法 虽然效率低 但是解决了返回给前端大小写的问题
	for i := 0; i < DefaultLength; i++ {
		map_item := utils.Struct2MapViaJson(RiskAndVulnerabilityItem[i])
		map_taskItemList = append(map_taskItemList, map_item)
	}

	// 计算一下需要如何切割数组
	ArrayStart, ArrayEnd := utils.CalculateReturnMapLength(pagenum, pagesize, map_taskItemList)
	// 返回切片后的结果
	return map_taskItemList[ArrayStart:ArrayEnd], DefaultLength
}

// 记录触发记录
func InsertTriggerLog(db *gorm.DB, triggerType string, name string, triggerURL string) {
	db.Debug().Model(&model.RiskAndVulnerabilityLog{}).Create(&model.RiskAndVulnerabilityLog{Type: triggerType, URL: triggerURL, Name: name})
}

// 查询所有脆弱性和风险的触发记录
func SelectAllRiskAndVulnerabilityLogDAO(db *gorm.DB, obj dto.GetAllRiskAndVulnerabilityLogDTOReq) ([]map[string]interface{}, int) {
	RiskAndVulnerabilityLogItem := []model.RiskAndVulnerabilityLog{}
	query := obj.Query
	pagenum := obj.Pagenum
	pagesize := obj.Pagesize
	map_RiskAndVulnerabilityLogItemList := []map[string]interface{}{}

	// 不带Query，返回全部
	// 否则返回like搜索后的结果
	if query == "" {
		// 按照时间升序
		db.Limit(1000).Order("created_at desc").Model(&model.RiskAndVulnerabilityLog{}).Find(&RiskAndVulnerabilityLogItem)
	} else {
		// 按照时间升序
		db.Limit(1000).Order("created_at desc").Where("\"name\" LIKE ?", "%"+query+"%").Model(&model.RiskAndVulnerabilityLog{}).Find(&RiskAndVulnerabilityLogItem)
	}
	DefaultLength := len(RiskAndVulnerabilityLogItem)

	// 把一个自定义结构体的array 转换成map的array
	// 这里用了json的方法 虽然效率低 但是解决了返回给前端大小写的问题
	for i := 0; i < DefaultLength; i++ {
		map_item := utils.Struct2MapViaJson(RiskAndVulnerabilityLogItem[i])
		map_RiskAndVulnerabilityLogItemList = append(map_RiskAndVulnerabilityLogItemList, map_item)
	}

	// 计算一下需要如何切割数组
	ArrayStart, ArrayEnd := utils.CalculateReturnMapLength(pagenum, pagesize, map_RiskAndVulnerabilityLogItemList)
	// 返回切片后的结果
	return map_RiskAndVulnerabilityLogItemList[ArrayStart:ArrayEnd], DefaultLength
}

<template>
  <div
    v-loading.fullscreen.lock="isLoading"
    :element-loading-text="loadingContent"
    element-loading-spinner="el-icon-loading"
    element-loading-background="rgba(0, 0, 0, 0.8)"
  >
    <el-row :gutter="20">
      <!-- 这个列里面放的是搜索框 -->
      <el-col :span="6">
        <el-input
          placeholder="请输入脆弱性或风险名称"
          clearable
          v-model="queryInfo.query"
          @clear="GetRiskAndVulnerabilityList"
          @change="GetRiskAndVulnerabilityList"
        >
          <el-button slot="append" icon="el-icon-search"></el-button>
        </el-input>
      </el-col>

      <!-- 这个列里面放的是触发全部脆弱性与风险的框 -->
      <el-col :span="8">
        <el-button type="primary" @click="TriggerAll">全部触发</el-button>
        <el-button type="warning" @click="TriggerOnlyVulnerability">仅触发脆弱性</el-button>
        <el-button type="warning" @click="TriggerOnlyRisk">仅触发风险</el-button>

        <el-tooltip class="item" effect="dark" placement="top-start">
          <div slot="content">强制容器进行审计,实现日志落盘</div>
          <el-button type="danger" @click="ForceAudit">立即审计</el-button>
        </el-tooltip>
      </el-col>
    </el-row>
    <!-- 分割线 -->
    <el-divider></el-divider>

    <el-table
      :data="riskAndVulnerabilityList"
      stripe
      border
      style="width: 100%"
      @filter-change="filterChangeInit"
    >
      <el-table-column type="index" label="序号" width="50" align="center"></el-table-column>
      <el-table-column
        label="类别"
        width="80"
        align="center"
        prop="type"
        column-key="type"
        :filters="[{ text: '脆弱性', value: '脆弱性' }, { text: '风险', value: '风险' }]"
        :filter-method="filterTag"
        :filter-multiple="false"
      >
        <template slot-scope="scope">
          <el-tag v-if="scope.row.type == '脆弱性'">{{ scope.row.type }}</el-tag>
          <el-tag type="success" v-if="scope.row.type == '风险'">{{ scope.row.type }}</el-tag>
        </template>
      </el-table-column>
      <el-table-column prop="name" label="名称" width="200"></el-table-column>
      <el-table-column prop="desc" label="描述"></el-table-column>
      <el-table-column label="危险级别" width="80" align="center">
        <template slot-scope="scope">
          <el-tag v-if="scope.row.level=='高危'" type="danger" effect="dark">{{ scope.row.level }}</el-tag>
          <el-tag v-if="scope.row.level=='中危'" type="warning" effect="dark">{{ scope.row.level }}</el-tag>
          <el-tag v-if="scope.row.level=='低危'" effect="dark">{{ scope.row.level }}</el-tag>
        </template>
      </el-table-column>
      <el-table-column label="操作" width="150" align="center">
        <template slot-scope="scope">
          <!-- 触发风险或者脆弱性 -->
          <el-tooltip
            class="item"
            effect="dark"
            content="触发该风险或脆弱性"
            placement="top"
            :enterable="false"
          >
            <a style="margin-right:10px; padding-top:10px">
              <el-button
                type="success"
                icon="el-icon-aim"
                circle
                @click="TriggerThis(scope.row.name)"
              ></el-button>
            </a>
          </el-tooltip>
          <!-- 触发方式介绍 -->
          <el-tooltip
            class="item"
            effect="dark"
            content="触发方式介绍"
            placement="top"
            :enterable="false"
          >
            <el-button
              type="warning"
              icon="el-icon-question"
              @click="OpenTriggerMethodDialog(scope.row.triggermethod)"
              circle
            ></el-button>
          </el-tooltip>
        </template>
      </el-table-column>
    </el-table>

    <!-- 分页功能 -->
    <el-pagination
      @size-change="handleSizeChange"
      @current-change="handleCurrentChange"
      :current-page="queryInfo.pagenum"
      :page-sizes="[10, 50, 100]"
      :page-size="queryInfo.pagesize"
      layout="total, sizes, prev, pager, next, jumper"
      :total="total"
    ></el-pagination>

    <el-dialog
      title="触发方法介绍"
      :visible.sync="triggerMethodDialogVisible"
      width="30%"
      :close-on-click-modal="false"
      @close="triggerMethodDialogVisible = false"
    >
      <div style="white-space: pre-line;">{{ triggerMethod }}</div>
      <span slot="footer" class="dialog-footer">
        <el-button @click="triggerMethodDialogVisible = false">关闭</el-button>
      </span>
    </el-dialog>
  </div>
</template>

<script>
import qs from 'qs'
import { faker } from '@faker-js/faker'
// faker.setLocale('zh_CN')
export default {
  data() {
    return {
      queryInfo: {
        // 查询字符
        query: '',
        // 这行属性其实就是当前在第几页
        pagenum: 1,
        // 这行属性其实就是当前每页展示多少条数据，这里最好与page-sizes里面的第一个元素值保持一致，否则在刷新的时候会出Bug
        pagesize: 10,
        // 这行是类别,确定是风险还是脆弱性
        type: '',
      },

      passwordInfo: {
        password: '123456',
        // account: 'user',
      },

      // 结果总数 用于翻页
      total: 0,

      // 获取到的脆弱性风险数据
      riskAndVulnerabilityList: [],

      // 脆弱性与风险触发方法的对话框
      triggerMethodDialogVisible: false,

      // 触发方法
      triggerMethod: '',

      // 遮罩
      isLoading: false,
      loadingContent: '',
    }
  },
  created() {
    this.GetRiskAndVulnerabilityList()
  },
  methods: {
    // 强制立即审计
    async ForceAudit() {
      this.$confirm(
        '确定强制立刻进行审计并生成日志?该功能仅建议测试使用',
        '提示',
        {
          confirmButtonText: '确定',
          cancelButtonText: '取消',
          type: 'warning',
        }
      )
        .then(async () => {
          // const { data: res } = await this.$http.delete('tasks/')
          this.loadingContent = '强制审计中'
          this.isLoading = true

          const { data: res } = await this.$http.get('custom/forceaudit')

          this.isLoading = false

          if (res.meta.status_code == 200) {
            return this.$message({
              type: 'success',
              message: '强制审计成功!',
            })
          } else {
            return this.$message.error(res.meta.message)
          }
        })
        .catch(() => {
          this.isLoading = false
          this.$message({
            type: 'info',
            message: '已取消强制审计',
          })
        })
    },
    // 仅触发脆弱性
    async TriggerOnlyVulnerability() {
      this.$confirm('确定触发全部脆弱性?', '提示', {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning',
      })
        .then(async () => {
          var flag = 0

          const { data: res } = await this.$http.get(
            'custom/riskandvulnerability',
            {
              params: {
                pagenum: 1,
                pagesize: 100,
              },
            }
          )

          // 显示遮罩
          this.isLoading = true

          for (var i = 0; i < res.data.Total; i++) {
            if (res.data.RiskAndVulnerabilityList[i]['type'] == '脆弱性') {
              this.loadingContent =
                '触发' + res.data.RiskAndVulnerabilityList[i]['name'] + '中'

              var status_code = await this.DoRequest(
                res.data.RiskAndVulnerabilityList[i]['name']
              )
            }

            if (status_code != 200) {
              this.isLoading = false
              console.log(
                res.data.RiskAndVulnerabilityList[i]['name'],
                '触发失败, 返回值为:',
                status_code
              )
              flag = 1
            }
          }

          this.isLoading = false

          if (flag == 0) {
            return this.$message({
              type: 'success',
              message: '全部脆弱性触发成功!',
            })
          } else {
            return this.$message({
              type: 'fail',
              message: '存在脆弱性触发失败!',
            })
          }
        })
        .catch(() => {
          this.isLoading = false
          this.$message({
            type: 'info',
            message: '已取消触发',
          })
        })
    },
    // 仅触发风险
    async TriggerOnlyRisk() {
      this.$confirm('确定触发全部风险?', '提示', {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning',
      })
        .then(async () => {
          var flag = 0
          const { data: res } = await this.$http.get(
            'custom/riskandvulnerability',
            {
              params: {
                pagenum: 1,
                pagesize: 100,
              },
            }
          )

          // 显示遮罩
          this.isLoading = true

          for (var i = 0; i < res.data.Total; i++) {
            console.log(res.data.RiskAndVulnerabilityList[i]['type'])
            if (res.data.RiskAndVulnerabilityList[i]['type'] == '风险') {
              this.loadingContent =
                '触发' + res.data.RiskAndVulnerabilityList[i]['name'] + '中'
              var status_code = await this.DoRequest(
                res.data.RiskAndVulnerabilityList[i]['name']
              )
              if (status_code != 200) {
                this.isLoading = false
                console.log(
                  res.data.RiskAndVulnerabilityList[i]['name'],
                  '触发失败, 返回值为:',
                  status_code
                )
                flag = 1
              }
            }
          }

          this.isLoading = false

          if (flag == 0) {
            return this.$message({
              type: 'success',
              message: '全部风险触发成功!',
            })
          } else {
            return this.$message({
              type: 'fail',
              message: '存在风险触发失败!',
            })
          }
        })
        .catch(() => {
          this.isLoading = false
          this.$message({
            type: 'info',
            message: '已取消触发',
          })
        })
    },
    // 触发全部脆弱性与风险的框
    async TriggerAll() {
      this.$confirm('确定触发全部风险和脆弱性?', '提示', {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning',
      })
        .then(async () => {
          var flag = 0
          const { data: res } = await this.$http.get(
            'custom/riskandvulnerability',
            {
              params: {
                pagenum: 1,
                pagesize: 100,
              },
            }
          )
          // 显示遮罩
          this.isLoading = true

          for (var i = 0; i < res.data.Total; i++) {
            this.loadingContent =
              '触发' + res.data.RiskAndVulnerabilityList[i]['name'] + '中'
            var status_code = await this.DoRequest(
              res.data.RiskAndVulnerabilityList[i]['name']
            )
            if (status_code != 200) {
              this.isLoading = false
              console.log(
                res.data.RiskAndVulnerabilityList[i]['name'],
                '触发失败, 返回值为:',
                status_code
              )
              flag = 1
            }
          }

          this.isLoading = false

          if (flag == 0) {
            return this.$message({
              type: 'success',
              message: '全部风险与脆弱性触发成功!',
            })
          } else {
            return this.$message({
              type: 'fail',
              message: '存在风险与脆弱性触发失败!',
            })
          }
        })
        .catch(() => {
          this.isLoading = false
          this.$message({
            type: 'info',
            message: '已取消触发',
          })
        })
    },
    // 获取有哪些脆弱性和风险
    async GetRiskAndVulnerabilityList() {
      const { data: res } = await this.$http.get(
        'custom/riskandvulnerability',
        {
          params: this.queryInfo,
        }
      )
      if (res.meta.status_code !== 200)
        return this.$message.error('获取脆弱性与风险失败')

      // 成功了就开始赋值
      this.riskAndVulnerabilityList = res.data.RiskAndVulnerabilityList
      this.total = res.data.Total
      console.log('脆弱性与风险: ', this.riskAndVulnerabilityList)
    },
    // 翻页
    handleCurrentChange(val) {
      // console.log(`当前页: ${val}`)
      this.queryInfo.pagenum = val
      this.GetRiskAndVulnerabilityList()
    },
    // 改变每页大小
    handleSizeChange(val) {
      // console.log(`每页 ${val} 条`)
      this.queryInfo.pagesize = val
      this.GetRiskAndVulnerabilityList()
    },
    // 进行请求
    async DoRequest(name) {
      switch (name) {
        // 1 已完成
        case 'url中存在密码信息': {
          const { data: res } = await this.$http.get(
            'custom/mock/vulnerability/PswdInURL',
            {
              params: this.passwordInfo,
            }
          )
          return res.meta.status_code
        }
        // 2 已完成
        case '响应数据存在密码信息': {
          const { data: res } = await this.$http.get(
            'custom/mock/vulnerability/PswdInResp'
          )
          return res.meta.status_code
        }
        // 3 已完成
        case 'cookie中存在密码信息': {
          document.cookie = 'password=qwert;'
          const { data: res } = await this.$http.get(
            'custom/mock/vulnerability/PswdInCookie'
          )

          document.cookie =
            'password=qwert;expires=' + new Date(0).toUTCString()

          return res.meta.status_code
        }
        // 4 已完成
        case '请求数据存在明文密码信息': {
          const { data: res } = await this.$http.post(
            'custom/mock/vulnerability/PswdInPlainText',
            {
              password: 123456,
            }
          )
          return res.meta.status_code
        }
        // 5 已完成
        case '登录弱密码': {
          const loginForm = {
            name: 'admin',
            password: 'admin',
          }
          const { data: res } = await this.$http.post(
            'custom/mock/vulnerability/WeakPasswd',
            qs.stringify(loginForm)
          )
          return res.meta.status_code
        }
        // 6 已完成
        case '响应数据存在明文密码信息': {
          const { data: res } = await this.$http.get(
            'custom/mock/vulnerability/PswdInPlainTextResp'
          )
          return res.meta.status_code
        }
        // 7 已完成
        case 'GET方式执行危险操作': {
          const { data: res } = await this.$http.get(
            'custom/mock/vulnerability/DeleteInGet?delete=1'
          )
          return res.meta.status_code
        }
        // 8 已完成
        case '鉴权信息在url中': {
          const { data: res } = await this.$http.get(
            'custom/mock/vulnerability/AuthInURL?sessionid=456'
          )
          return res.meta.status_code
        }
        // 9 已完成
        case '敏感信息在url中': {
          const { data: res } = await this.$http.get(
            'custom/mock/vulnerability/SensitiveDataInURL?phone=13687148956'
          )
          return res.meta.status_code
        }
        // 10 已完成
        case '敏感接口未鉴权': {
          const xhr = new XMLHttpRequest()

          let host = window.location.host //主机
          if (process.env.NODE_ENV == 'production') {
            xhr.open(
              'POST',
              'http://' +
                host +
                '/api/auth/custom/mock/vulnerability/SensitiveAPINotSec'
            )
          } else {
            xhr.open(
              'POST',
              'http://localhost:8081/api/auth/custom/mock/vulnerability/SensitiveAPINotSec'
            )
          }
          xhr.send('name=施耐庵')
          return 200
        }
        // 11 已完成
        case '非敏感接口未鉴权': {
          const xhr = new XMLHttpRequest()
          let host = window.location.host //主机
          if (process.env.NODE_ENV == 'production') {
            xhr.open(
              'POST',
              'http://' +
                host +
                '/api/auth/custom/mock/vulnerability/NoneSensitiveAPINotSec'
            )
          } else {
            xhr.open(
              'POST',
              'http://localhost:8081/api/auth/custom/mock/vulnerability/NoneSensitiveAPINotSec'
            )
          }
          xhr.send()
          return 200
        }
        // 12 已完成
        case '敏感接口返回数据量可修改': {
          const { data: res } = await this.$http.get(
            'custom/mock/vulnerability/DataAmountCanBeModified?query=&pagenum=1&pagesize=10'
          )
          return res.meta.status_code
        }

        // 13 已完成
        case '单次访问数据量过大': {
          const { data: res } = await this.$http.get(
            'custom/mock/vulnerability/TooMuchDataInSingleRequest'
          )
          return res.meta.status_code
        }

        // 14 已完成
        case '单次访问敏感类型过多': {
          const { data: res } = await this.$http.get(
            'custom/mock/vulnerability/TooMuchTypeInSingleRequest'
          )
          return res.meta.status_code
        }

        // 15 已完成
        case '脱敏策略不一致': {
          const { data: res } = await this.$http.get(
            'custom/mock/vulnerability/DifferentDesensePolicy'
          )
          return res.meta.status_code
        }

        // 16 已完成
        case 'Hadoop未授权访问': {
          const xhr = new XMLHttpRequest()
          let host = window.location.host //主机
          if (process.env.NODE_ENV == 'production') {
            xhr.open(
              'POST',
              'http://' +
                host +
                '/api/auth/custom/mock/vulnerability/ws/v1/cluster/apps/new-application'
            )
          } else {
            xhr.open(
              'POST',
              'http://localhost:8081/api/auth/custom/mock/vulnerability/ws/v1/cluster/apps/new-application'
            )
          }
          xhr.send()
          return 200
        }

        // 17 已完成
        case 'SonarQube未授权访问': {
          if (process.env.NODE_ENV == 'production') {
            fetch('http://' + location.host + '/api/settings/values')
          } else {
            fetch('http://localhost:8081/api/settings/values')
          }
          return 200
        }

        // 18 已完成
        case 'ssh secret key信息泄露': {
          const { data: res } = await this.$http.post(
            'custom/mock/vulnerability/fileDownload',
            {
              path: '/root/.ssh/id_rsa',
            }
          )
          return res.meta.status_code
        }

        // 19 已完成
        case 'JDBC连接字符串信息泄露': {
          const { data: res } = await this.$http.post(
            'custom/mock/vulnerability/xxl-conf-admin/conf/find',
            {
              accessToken: '',
              env: 'product',
              keys: [
                'shenzhen.datasource',
                'shenzhen.base',
                'shenzhen.mongodb',
                'shenzhen.ipconfig',
                'shenzhen.xxl.job',
                'shenzhen.feign',
                'shenzhen.ipconfig2',
                'shenzhen.redis',
              ],
            }
          )
          return res.meta.status_code
        }

        // 20 已完成
        case 'Alibaba Nacos未授权访问': {
          const { data: res } = await this.$http.post(
            'custom/mock/vulnerability/nacos/v1/auth/users?username=yangy1&password=yangy',
            {
              'User-Agent': 'Nacos-Server',
            }
          )
          return res.meta.status_code
        }

        // 风险
        // 1. 账号多地访问(已完成)
        case '账号多地访问': {
          const { data: res } = await this.$http.get(
            'custom/mock/risk/OneAccountWithMultiPlace'
          )
          return res.meta.status_code
        }

        // 2. 账号多IP访问(已完成)
        case '账号多IP访问': {
          const { data: res } = await this.$http.get(
            'custom/mock/risk/OneAccountWithMultiIP'
          )
          return res.meta.status_code
        }

        // 3. 境内IP有多个账号身份(已完成)
        case '境内IP有多个账号身份': {
          const { data: res } = await this.$http.get(
            'custom/mock/risk/LocalIPWithMultiAccount'
          )
          return res.meta.status_code
        }

        // 4. 境外IP有多个账号身份(已完成)
        case '境外IP有多个账号身份': {
          const { data: res } = await this.$http.get(
            'custom/mock/risk/ForeignIPWithMultiAccount'
          )
          return res.meta.status_code
        }

        // 5. 单个账号一段时间内返回大量敏感数据(已完成)
        case '单个账号一段时间内返回大量敏感数据': {
          const { data: res } = await this.$http.get(
            'custom/mock/risk/SingleAccountReturnTooMuchSensitiveDataPeriod'
          )
          return res.meta.status_code
        }

        // 6. 单个IP一段时间内返回大量敏感数据(已完成)
        case '单个IP一段时间内返回大量敏感数据': {
          const { data: res } = await this.$http.get(
            'custom/mock/risk/SingleIPReturnTooMuchSensitiveDataPeriod'
          )
          return res.meta.status_code
        }

        // 7. 单个账号单次返回大量敏感数据(已完成)
        case '单个账号单次返回大量敏感数据': {
          const { data: res } = await this.$http.get(
            'custom/mock/risk/SingleAccountReturnTooMuchSensitiveDataOnce'
          )
          return res.meta.status_code
        }

        // 8. 单个IP单次返回大量敏感数据(已完成)
        case '单个IP单次返回大量敏感数据': {
          const { data: res } = await this.$http.get(
            'custom/mock/risk/SingleIPReturnTooMuchSensitiveDataOnce'
          )
          return res.meta.status_code
        }

        // 9. 单个账号单次返回敏感数据类型超过15种(已完成)
        case '单个账号单次返回敏感数据类型超过15种': {
          const { data: res } = await this.$http.get(
            'custom/mock/risk/SingleAccountReturnTooManyKindsOfSensitiveDataOnce'
          )
          return res.meta.status_code
        }

        // 10. 单个IP单次返回敏感数据类型超过15种(已完成)
        case '单个IP单次返回敏感数据类型超过15种': {
          const { data: res } = await this.$http.get(
            'custom/mock/risk/SingleIPReturnTooManyKindsOfSensitiveDataOnce'
          )
          return res.meta.status_code
        }

        // 11. 单个账号单次返回新类型的敏感数据
        case '单个账号单次返回新类型的敏感数据': {
          // // 时间切换到8天前
          // await this.$http.get('custom/modifydate/-8 day')

          // // 开始让前7天都有数据
          // for (var i = 0; i < 7; i++) {
          //   await this.$http.get('custom/modifydate/+1 day')
          //   await this.$http.get(
          //     'custom/mock/risk/SingleAccountReturnNewTypeSensiDataOnce'
          //   )
          // }

          // // 时间切换回来
          // await this.$http.get('custom/modifydate/+1 day')
          const { data: res } = await this.$http.get(
            'custom/mock/risk/SingleAccountReturnNewTypeSensiDataOnce'
          )

          return res.meta.status_code
        }

        // 12. 单个IP单次返回新类型的敏感数据
        case '单个IP单次返回新类型的敏感数据': {
          const { data: res } = await this.$http.get(
            'custom/mock/risk/SingleIPReturnNewTypeSensiDataOnce'
          )
          return res.meta.status_code
        }
        // 13. 单个账号在一段时间内进行请求参数值遍历(已完成)
        case '单个账号在一段时间内进行请求参数值遍历': {
          for (let index = 0; index < 100; index++) {
            await this.$http.get(
              'custom/mock/risk/SingleAccountRequestTraversePeriod?user=' +
                faker.name.lastName()
            )
          }
          return 200
        }
        // 14. 单个IP在一段时间内进行请求参数值遍历(已完成)
        case '单个IP在一段时间内进行请求参数值遍历': {
          for (let index = 0; index < 100; index++) {
            await this.$http.get(
              'custom/mock/risk/SingleIPRequestTraversePeriod?user=' +
                faker.name.lastName()
            )
          }
          return 200
        }
        // 15. 请求参数值出现新类型
        case '请求参数值出现新类型': {
          const { data: res } = await this.$http.get(
            'custom/mock/risk/NewTypeInRequest'
          )
          return res.meta.status_code
        }
        // 16. 请求方法异常
        case '请求方法异常': {
          const { data: res } = await this.$http.get(
            'custom/mock/risk/AbnormalRequestMethod'
          )
          return res.meta.status_code
        }
        // 17. 单个账号在一段时间内返回大量4XX(已完成)
        case '单个账号在一段时间内返回大量4XX': {
          for (let index = 0; index < 100; index++) {
            await this.$http.get(
              'custom/mock/risk/SingleAccountReturnTooMuch4XXPeriod'
            )
          }
          return 200
        }
        // 18. 单个IP在一段时间内返回大量4XX(已完成)
        case '单个IP在一段时间内返回大量4XX': {
          for (let index = 0; index < 100; index++) {
            await this.$http.get(
              'custom/mock/risk/SingleIPReturnTooMuch4XXPeriod'
            )
          }
          return 200
        }
        // 19. 单个账号在一段时间内频繁访问同一API(已完成)
        case '单个账号在一段时间内频繁访问同一API': {
          for (let index = 0; index < 100; index++) {
            await this.$http.get(
              'custom/mock/risk/SingleAccountVisitSameAPIPeriod'
            )
          }
          return 200
        }
        // 20. 单个账号在异常时间段频繁访问同一API(已完成)
        case '单个账号在异常时间段频繁访问同一API': {
          for (let index = 0; index < 100; index++) {
            await this.$http.get(
              'custom/mock/risk/SingleAccountVisitSameAPIAbnormalPeriod'
            )
          }
          return 200
        }
        // 21. 单个IP在一段时间内频繁访问同一API(已完成)
        case '单个IP在一段时间内频繁访问同一API': {
          for (let index = 0; index < 100; index++) {
            await this.$http.get('custom/mock/risk/SingleIPVisitSameAPIPeriod')
          }
          return 200
        }
        // 22. 单个IP在异常时间段频繁访问同一API(已完成)
        case '单个IP在异常时间段频繁访问同一API': {
          for (let index = 0; index < 100; index++) {
            await this.$http.get(
              'custom/mock/risk/SingleIPVisitSameAPIAbnormalPeriod'
            )
          }
          return 200
        }
        // 23. 请求参数名缺失
        case '请求参数名缺失': {
          const { data: res } = await this.$http.get(
            'custom/mock/risk/LackOfVarName'
          )
          return res.meta.status_code
        }
        // 24. 请求参数出现非预期的参数名
        case '请求参数出现非预期的参数名': {
          const { data: res } = await this.$http.get(
            'custom/mock/risk/UnexpectedVarName'
          )
          return res.meta.status_code
        }
        // 25. 单个账号在一段时间内进行路径遍历(已完成)
        case '单个账号在一段时间内进行路径遍历': {
          for (let index = 0; index < 200; index++) {
            await this.$http.get(
              'custom/mock/risk/SingleAccountPathTraversePeriod/' +
                faker.name.firstName()
            )
          }
          return 200
        }
        // 26. 单个IP在一段时间内进行路径遍历(已完成)
        case '单个IP在一段时间内进行路径遍历': {
          for (let index = 0; index < 200; index++) {
            await this.$http.get(
              'custom/mock/risk/SingleIPPathTraversePeriod/' +
                faker.name.firstName()
            )
          }
          return 200
        }
      }
    },
    // 触发脆弱性和风险
    TriggerThis(name) {
      this.$confirm('确定触发此风险或脆弱性?', '提示', {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning',
      })
        .then(async () => {
          const status_code = await this.DoRequest(name)
          console.log('响应码是', status_code)

          if (status_code == 200) {
            return this.$message({
              type: 'success',
              message: '触发成功!',
            })
          } else {
            return this.$message.error({
              message: '触发失败!',
            })
          }
        })
        .catch(() => {
          this.$message({
            type: 'info',
            message: '已取消触发',
          })
        })
    },
    // 展示触发的方法
    OpenTriggerMethodDialog(tiggermethod) {
      this.triggerMethodDialogVisible = true
      this.triggerMethod = tiggermethod
    },
    // 过滤
    filterTag() {
      return true
    },
    //
    filterChangeInit(filters) {
      // console.log('filters: ', filters.type[0])
      if (filters.type) {
        this.queryInfo.type = filters.type[0]
        console.log('this.queryInfo.type', this.queryInfo.type)
        this.GetRiskAndVulnerabilityList()
      }
    },
  },
}
</script>

<style>
</style>